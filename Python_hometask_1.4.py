 '''
 Задание 9

Найти максимальный элемент среди минимальных элементов столбцов матрицы.
Есть столбцы матрицы, каждый столбец содержит минимальное число, например для матрицы 3 × 5 будет 5 таких чисел,
среди этих 5 чисел нужно найти максимальное

Матрица [[1, 2], [3, 4]] у неё столбцы 1, 3 и 2, 4. В первом столбце минимальный элемент 1, во втором 2.
Максимальный элемент между 1 и 2 это 2. Ответ: 2

 '''

 # Вариант 1 Numpy

x = np.random.randint(16, size=(3,5)).astype('uint8')
def minimax_1 (x):
    l_min = []
    for i in x.T:
        b = i.min()
        l_min.append(b)

    return ("Максимальное число {}".format(max(l_min)))

# Вариант 2 Алгоритмический
b = np.random.randint(16, size=(3,5)).astype('uint8')

def minimax_2 (b):
    #Переставим минимальное значение в колонках на первое место

    f=[]
    for j in range(len(b[0])): # идем по всей длине строки, получаем индексы колонок
        mini = b[0][j]
        for k in range(len(b)): #получаем индексы остальных строк
            if b[k][j] < mini: # если находим значение меньше минимального
                mini = b[k][j] # присваиваем минимальное значение
        f.append(mini)

    return ("Максимальное число {}".format(max(f)))

t1 = timeit.timeit('minimax_1(x)', setup="from __main__ import minimax_1, x", number=1000)
t2 = timeit.timeit('minimax_2(b)', setup="from __main__ import minimax_2, b", number=1000)
cProfile.run('minimax_1 (x)')
cProfile.run('minimax_2 (b)')

'''
Вариант 2 требует меньше времени.

(0.05230714500066824, 0.030556582001736388)

Варианты почему:
- не переворавичиваем матрицу
- больше использует алгоритмический подход, а не встроенные методы из библиотеки numpy

Сложность алгоритма линейная и зависит от объема массива.

'''
