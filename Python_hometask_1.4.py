import numpy as np
import cProfile
import timeit
import memory_profiler

 '''
 Задание 1

Найти максимальный элемент среди минимальных элементов столбцов матрицы.
Есть столбцы матрицы, каждый столбец содержит минимальное число, например для матрицы 3 × 5 будет 5 таких чисел,
среди этих 5 чисел нужно найти максимальное

Матрица [[1, 2], [3, 4]] у неё столбцы 1, 3 и 2, 4. В первом столбце минимальный элемент 1, во втором 2.
Максимальный элемент между 1 и 2 это 2. Ответ: 2

 '''

 # Вариант 1 Numpy

x = np.random.randint(16, size=(3,5)).astype('uint8')
def minimax_1 (x):
    l_min = []
    for i in x.T:
        b = i.min()
        l_min.append(b)

    return ("Максимальное число {}".format(max(l_min)))

# Вариант 2 Алгоритмический
b = np.random.randint(16, size=(3,5)).astype('uint8')

def minimax_2 (b):
    #Переставим минимальное значение в колонках на первое место

    f=[]
    for j in range(len(b[0])): # идем по всей длине строки, получаем индексы колонок
        mini = b[0][j]
        for k in range(len(b)): #получаем индексы остальных строк
            if b[k][j] < mini: # если находим значение меньше минимального
                mini = b[k][j] # присваиваем минимальное значение
        f.append(mini)

    return ("Максимальное число {}".format(max(f)))

# Оценка сложности алгоритма

t1 = timeit.timeit('minimax_1(x)', setup="from __main__ import minimax_1, x", number=1000)
t2 = timeit.timeit('minimax_2(b)', setup="from __main__ import minimax_2, b", number=1000)
cProfile.run('minimax_1 (x)')
cProfile.run('minimax_2 (b)')

%load_ext memory_profiler
%memit minimax_1(x)
%memit minimax_2(x)

'''
Вариант 2 требует меньше времени.

(0.05230714500066824, 0.030556582001736388)

Варианты почему:
- не переворавичиваем матрицу
- больше использует алгоритмический подход, а не встроенные методы из библиотеки numpy

Кроме этого, объем памяти, который необходим алгоритму вариант 2, гораздо меньше, чем в варианте 1.

Вариант 1. peak memory: 40.52 MiB, increment: 0.11 MiB
Вариант 2. peak memory: 40.54 MiB, increment: 0.02 MiB

increment = peak memory - starting memory и во втором алгоритме почти в 6 раз меньше.

Сложность алгоритма линейная и зависит от объема массива.

'''

'''
Задание 2. Решето Эратосфена

'''


# Вариант 1. Базовый.


def eratosphen_1():
    #n = int(input("вывод простых чисел до числа ... "))
    n = 50
    a = [0] * n  # создание массива с n количеством элементов
    for i in range(n):  # заполнение массива ...
        a[i] = i  # значениями от 0 до n-1
    # вторым элементом является единица, которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0

    m = 2  # замена на 0 начинается с 3-го элемента (первые два уже нули)
    while m < n:  # перебор всех элементов до заданного числа
        if a[m] != 0:  # если он не равен нулю, то
            j = m * 2  # увеличить в два раза (текущий элемент простое число), потому что, все четные числа, кроме двойки,
            #- составные, т. е. не являются простыми, так как делятся не только на себя и единицу, а также еще на 2."
            while j < n:
                a[j] = 0  # заменить на 0
                j = j + m  # перейти в позицию на m больше
        m += 1

    # вывод простых чисел на экран (может быть реализован как угодно)
    b = []
    for i in a:
        if a[i] != 0:
            b.append(a[i])
    del a
    return(b)

#Вариант 2. Упрощенный

def eratosphen_2():
    #n = int(input("вывод простых чисел до числа ... "))
    n = 50
    a = [0] * n  # создание массива с n количеством элементов
    for i in range(n):  # заполнение массива ...
        a[i] = i  # значениями от 0 до n-1

    # вторым элементом является единица, которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0

    m = 2  # замена на 0 начинается с 3-го элемента (первые два уже нули)
    while m < n:  # перебор всех элементов до заданного числа
        if a[m] != 0:  # если он не равен нулю, то
            j = m * 2  # увеличить в два раза (текущий элемент простое число)
            while j < n:
                a[j] = 0  # заменить на 0
                j = j + m  # перейти в позицию на m больше
        m += 1

    a = set(a)
    # удаляем ноль
    a.remove(0)
    return (a)

# Оценка сложности алгоритмов

ert_1 = timeit.timeit('eratosphen_1()', setup="from __main__ import eratosphen_1", number=10000)
ert_2 = timeit.timeit('eratosphen_2()', setup="from __main__ import eratosphen_2", number=10000)
%load_ext memory_profiler
%memit eratosphen_1()
%memit eratosphen_2()

'''

Второй вариант работает гораздо быстрее, так как упрощена схема вывода результатов, не создается дополнительно массив для этого
за счет использования множества set

Вариант1 0.34642014800010656, Вариант 2 - 0.22776638899995305

peak memory: 38.62 MiB, increment: 0.53 MiB
peak memory: 38.68 MiB, increment: 0.04 MiB

increment = peak memory - starting memory и во втором алгоритме почти в 10 раз меньше.

Сложность алгоритма линейная.


'''
